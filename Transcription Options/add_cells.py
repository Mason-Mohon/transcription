import json

# Read the notebook
with open('/Users/mason/Desktop/Transcription Options/transcription_comparison_analysis.ipynb', 'r') as f:
    notebook = json.load(f)

print(f'Original notebook has {len(notebook["cells"])} cells')

# Add new cells
new_cells = [
    {
        'cell_type': 'code',
        'metadata': {},
        'source': [
            'def find_common_errors(reference, hypothesis, n_errors=10):\n',
            '    """Find most common word substitution errors."""\n',
            '    ref_words = reference.split()\n',
            '    hyp_words = hypothesis.split()\n',
            '    \n',
            '    matcher = difflib.SequenceMatcher(None, ref_words, hyp_words)\n',
            '    substitutions = []\n',
            '    \n',
            '    for tag, i1, i2, j1, j2 in matcher.get_opcodes():\n',
            '        if tag == "replace":\n',
            '            # Handle word substitutions\n',
            '            ref_segment = " ".join(ref_words[i1:i2])\n',
            '            hyp_segment = " ".join(hyp_words[j1:j2])\n',
            '            if ref_segment and hyp_segment:\n',
            '                substitutions.append((ref_segment, hyp_segment))\n',
            '    \n',
            '    # Count substitution frequency\n',
            '    substitution_counts = Counter(substitutions)\n',
            '    \n',
            '    return substitution_counts.most_common(n_errors)\n',
            '\n',
            '# Perform advanced error analysis for each service\n',
            'error_analysis = {}\n',
            '\n',
            'for service, data in comparison_data.items():\n',
            '    print(f"\\nAnalyzing errors for {service.upper()}...")\n',
            '    \n',
            '    control_text = data["control_text"]\n',
            '    service_text = data["service_text"]\n',
            '    \n',
            '    # Common errors\n',
            '    common_errors = find_common_errors(control_text, service_text)\n',
            '    \n',
            '    error_analysis[service] = {\n',
            '        "common_errors": common_errors\n',
            '    }\n',
            '    \n',
            '    # Print summary\n',
            '    print(f"  Common substitutions: {len(common_errors)}")\n',
            '\n',
            'print("\\nError analysis completed!")'
        ]
    },
    {
        'cell_type': 'markdown',
        'metadata': {},
        'source': ['## 7. Visualization and Reporting {#visualization}']
    },
    {
        'cell_type': 'code',
        'metadata': {},
        'source': [
            '# Set up the plotting area\n',
            'fig, axes = plt.subplots(2, 3, figsize=(18, 12))\n',
            'fig.suptitle("Transcription Service Comparison Dashboard", fontsize=16, fontweight="bold")\n',
            '\n',
            '# Prepare data for plotting\n',
            'services = list(results.keys())\n',
            'service_labels = [s.replace("_", " ").title() for s in services]\n',
            '\n',
            '# 1. WER Comparison\n',
            'wers = [results[s]["overall"]["wer"] for s in services]\n',
            'bars1 = axes[0,0].bar(service_labels, wers, color="lightcoral")\n',
            'axes[0,0].set_title("Word Error Rate (WER)\\n(Lower is Better)")\n',
            'axes[0,0].set_ylabel("WER")\n',
            'axes[0,0].tick_params(axis="x", rotation=45)\n',
            '# Add value labels on bars\n',
            'for bar, wer in zip(bars1, wers):\n',
            '    axes[0,0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01, \n',
            '                   f"{wer:.3f}", ha="center", va="bottom")\n',
            '\n',
            '# 2. BLEU Score Comparison\n',
            'bleus = [results[s]["overall"]["bleu"] for s in services]\n',
            'bars2 = axes[0,1].bar(service_labels, bleus, color="lightblue")\n',
            'axes[0,1].set_title("BLEU Score\\n(Higher is Better)")\n',
            'axes[0,1].set_ylabel("BLEU Score")\n',
            'axes[0,1].tick_params(axis="x", rotation=45)\n',
            'for bar, bleu in zip(bars2, bleus):\n',
            '    axes[0,1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01, \n',
            '                   f"{bleu:.3f}", ha="center", va="bottom")\n',
            '\n',
            '# 3. Error Type Breakdown\n',
            'error_types = ["substitutions", "insertions", "deletions"]\n',
            'error_data = np.array([[results[s]["overall"]["errors"][et] for et in error_types] for s in services])\n',
            'bottom = np.zeros(len(services))\n',
            'colors = ["#ff9999", "#66b3ff", "#99ff99"]\n',
            '\n',
            'for i, error_type in enumerate(error_types):\n',
            '    axes[0,2].bar(service_labels, error_data[:, i], bottom=bottom, \n',
            '                  label=error_type.title(), color=colors[i])\n',
            '    bottom += error_data[:, i]\n',
            '\n',
            'axes[0,2].set_title("Error Type Breakdown")\n',
            'axes[0,2].set_ylabel("Number of Errors")\n',
            'axes[0,2].legend()\n',
            'axes[0,2].tick_params(axis="x", rotation=45)\n',
            '\n',
            '# 4. Word Count Comparison\n',
            'control_counts = [results[s]["overall"]["word_count_control"] for s in services]\n',
            'service_counts = [results[s]["overall"]["word_count_service"] for s in services]\n',
            '\n',
            'x = np.arange(len(services))\n',
            'width = 0.35\n',
            '\n',
            'axes[1,0].bar(x - width/2, control_counts, width, label="Control", color="lightgreen")\n',
            'axes[1,0].bar(x + width/2, service_counts, width, label="Service", color="lightsalmon")\n',
            'axes[1,0].set_title("Word Count Comparison")\n',
            'axes[1,0].set_ylabel("Word Count")\n',
            'axes[1,0].set_xticks(x)\n',
            'axes[1,0].set_xticklabels(service_labels, rotation=45)\n',
            'axes[1,0].legend()\n',
            '\n',
            '# 5. Similarity Scores\n',
            'similarities = [results[s]["overall"]["similarity"] for s in services]\n',
            'bars5 = axes[1,1].bar(service_labels, similarities, color="lightgreen")\n',
            'axes[1,1].set_title("Text Similarity\\n(Higher is Better)")\n',
            'axes[1,1].set_ylabel("Similarity Score")\n',
            'axes[1,1].tick_params(axis="x", rotation=45)\n',
            'axes[1,1].set_ylim(0, 1)\n',
            'for bar, sim in zip(bars5, similarities):\n',
            '    axes[1,1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01, \n',
            '                   f"{sim:.3f}", ha="center", va="bottom")\n',
            '\n',
            'plt.tight_layout()\n',
            'plt.show()'
        ]
    },
    {
        'cell_type': 'markdown',
        'metadata': {},
        'source': ['## 8. Summary and Recommendations {#summary}']
    },
    {
        'cell_type': 'code',
        'metadata': {},
        'source': [
            '# Create comprehensive summary report\n',
            'def generate_service_ranking():\n',
            '    """Generate overall service ranking based on multiple metrics."""\n',
            '    service_scores = {}\n',
            '    \n',
            '    for service in services:\n',
            '        overall = results[service]["overall"]\n',
            '        \n',
            '        # Composite score (weights can be adjusted based on priorities)\n',
            '        score = (\n',
            '            (1 - overall["wer"]) * 0.3 +      # WER (inverted, so lower is better)\n',
            '            overall["bleu"] * 0.25 +          # BLEU score\n',
            '            overall["similarity"] * 0.25 +    # Similarity\n',
            '            0.2                                 # Placeholder for other factors\n',
            '        )\n',
            '        \n',
            '        service_scores[service] = {\n',
            '            "score": score,\n',
            '            "wer": overall["wer"],\n',
            '            "bleu": overall["bleu"],\n',
            '            "similarity": overall["similarity"]\n',
            '        }\n',
            '    \n',
            '    # Sort by score (descending)\n',
            '    ranked_services = sorted(service_scores.items(), key=lambda x: x[1]["score"], reverse=True)\n',
            '    \n',
            '    return ranked_services\n',
            '\n',
            'def create_recommendation_matrix():\n',
            '    """Create use-case specific recommendations."""\n',
            '    recommendations = {\n',
            '        "Overall Best": "Based on combined metrics",\n',
            '        "Best for Accuracy": "Lowest Word Error Rate",\n',
            '        "Most Complete": "Highest word count vs control"\n',
            '    }\n',
            '    \n',
            '    # Find best service for each category\n',
            '    best_overall = min(services, key=lambda s: results[s]["overall"]["wer"])\n',
            '    best_accuracy = min(services, key=lambda s: results[s]["overall"]["wer"])\n',
            '    best_complete = max(services, key=lambda s: results[s]["overall"]["word_count_service"])\n',
            '    \n',
            '    category_winners = {\n',
            '        "Overall Best": best_overall,\n',
            '        "Best for Accuracy": best_accuracy,\n',
            '        "Most Complete": best_complete\n',
            '    }\n',
            '    \n',
            '    return category_winners\n',
            '\n',
            '# Generate ranking and recommendations\n',
            'ranked_services = generate_service_ranking()\n',
            'category_winners = create_recommendation_matrix()\n',
            '\n',
            'print("="*80)\n',
            'print("FINAL TRANSCRIPTION SERVICE COMPARISON REPORT")\n',
            'print("="*80)\n',
            '\n',
            'print(f"\\n📊 OVERALL RANKING (by composite score):")\n',
            'print("-" * 50)\n',
            'for i, (service, metrics) in enumerate(ranked_services, 1):\n',
            '    service_name = service.replace("_", " ").title()\n',
            '    print(f"{i}. {service_name:15} | Score: {metrics["score"]:.3f} | WER: {metrics["wer"]:.3f} | BLEU: {metrics["bleu"]:.3f}")\n',
            '\n',
            'print(f"\\n🏆 CATEGORY WINNERS:")\n',
            'print("-" * 50)\n',
            'for category, winner in category_winners.items():\n',
            '    winner_name = winner.replace("_", " ").title()\n',
            '    print(f"{category:20}: {winner_name}")\n',
            '\n',
            'print("\\n" + "="*80)'
        ]
    }
]

# Insert new cells before the metadata
notebook['cells'].extend(new_cells)

# Write back
with open('/Users/mason/Desktop/Transcription Options/transcription_comparison_analysis.ipynb', 'w') as f:
    json.dump(notebook, f, indent=1)

print(f'Successfully added {len(new_cells)} new cells to the notebook!')
print(f'Total cells now: {len(notebook["cells"])}')
